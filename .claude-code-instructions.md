# Claude Code Instructions

## Code Style & Architecture Preferences

### Service Architecture
- **Store instances, not factories**: Services should store instantiated objects (like `collection`) rather than recreating them on each method call
- **Keep both client and instance references**: When working with client-server patterns, store both the client and the specific instance (e.g., both `client` and `collection`)
- **Use specific methods over generic ones**: Prefer `createCollection()` when you know the collection doesn't exist, rather than `getOrCreateCollection()`

### Code Organization
- **Minimize method calls**: If a method just wraps `getOrCreateCollection()` and is called repeatedly, store the collection instead and use it directly
- **Direct access over getters**: Use direct property access (`this.collection.add()`) instead of helper methods that just return the property

### Error Handling
- **Implement fallbacks**: When a primary operation might fail (e.g., `client.reset()` due to permissions), implement a fallback approach (e.g., `client.deleteCollection()`)
- **Maintain service usability**: After destructive operations like `reset()`, ensure the service remains in a usable state (recreate necessary resources)

## Communication Style

### When Proposing Changes
- **Ask for clarification**: Don't assume the implementation approach - ask when multiple valid solutions exist
- **Be specific**: When explaining what you're about to do, be clear and concise
- **Accept feedback gracefully**: Be ready to pivot when given better suggestions

### Response Format
- **Be concise**: Get straight to the point
- **Show code changes clearly**: Highlight what changed and why
- **No unnecessary verbosity**: Avoid over-explaining obvious changes

## Development Workflow

### Before Implementing
1. Read relevant files first
2. Understand the existing architecture
3. Propose changes if the approach isn't obvious
4. Wait for confirmation before proceeding

### When Debugging
1. Run the failing command first
2. Analyze the error carefully
3. Check relevant files
4. Propose and implement fixes
5. Test to verify the fix works

### When Refactoring
- **Maintain existing patterns**: Follow the established code patterns in the project
- **Update all references**: When changing a constructor or method signature, update ALL usages
- **Test after changes**: Run the affected code to verify it works

## Technical Preferences

### TypeScript/Node.js
- Use async/await consistently
- Provide proper error messages with context
- Use logger instead of console.log
- Handle empty arrays/collections gracefully (early returns)

### ChromaDB Specific
- Store collection instances, not just the client
- Provide embeddings directly (don't rely on ChromaDB's default embedding function)
- Use `deleteCollection()` + `createCollection()` for reset operations instead of `client.reset()`

## General Guidelines

- **Don't over-engineer**: Implement exactly what's needed, nothing more
- **Question assumptions**: If something seems off, ask about it
- **Provide working solutions**: Ensure code compiles and runs before marking tasks complete
- **Learn from feedback**: When corrected, understand why and apply that knowledge going forward
